/* -------------------------------------------------------------------------- */
/* ---------------------------- bind, apply, call --------------------------- */
//? 바인딩? 연체 동물의 촉수같은 것. 여러 가지 값을 담지는 않지만 그러한 값들을 움켜지고 있다.
// ? 모든 함수가 가지고 있는 메서드이다. 
// * call -> 함수의 call 메서드를 호출할 때 객체를 전달하면 그 객체를 함수의 this에 할당하고 함수를 호출한다.  
/* -------------------------------------------------------------------------- */
function Mynameis() {
  console.log(`안녕하세요 제 이름은 ${this} 입니다!`);
}

Mynameis.call('Jurney'); // 안녕하세요 제이름은 Jurney 입니다.
/* -------------------------------------------------------------------------- */
//* Mynameis라는 함수의 this에 Jurney가 할당하여 호출함
//? 함수가 인자를 전달받아야한다면 

function Iam(place) {
  console.log(`안녕하세요 제 이름은 ${this} 입니다. 저는 ${place}에 살아요`);
}

Iam.call('Jurney', '한국');

/* -------------------------------------------------------------------------- */
// * apply -> 매개변수를 배열로 받는다. call? 매개변수를 직접 받음.
function IamApply(place) {
  console.log(`안녕하세요 제 이름은 ${this} 입니다. 저는 ${place}에 살아요`);
}

IamApply.apply('Jurney', ['한국']);
/* -------------------------------------------------------------------------- */
// ? 좀 더 유용하게 -> 두 배열을 하나로 합칠 수 있다!!
let age = [27, 25];
let member = ['최지연', '변혜빈'];

age.push.apply(age, member)
console.log(age);
// 조금 더 
/* -------------------------------------------------------------------------- */

//* bind -> 인자로 객체를 전달하면 그 함수의 this를 객체로 할당한 함수를 반환한다
// ! 객체에서 함수를 값으로 할당되었을때 this 참조가 어려운 이유.
//  * call and apply와 달리 함수를 호출하지 않고 함수를 반환!

function IamBind(place) {
  console.log(`안녕하세요 제 이름은 ${this} 입니다. 저는 ${place}에 살아요`);
}

hellojurney = IamBind.bind('jurney', ['서울']);
hellojurney();

/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */
/*                            Promise, async await                            */
/* -------------------------------------------------------------------------- */

// ? Promise객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냄
// ? 비동기 작업의 단위
// ? pending : 이행하지도, 거부하지도 않은 초기 상태
// ? fullfilled : 연산이 성공적으로 완료됨.
// ? rejected : 연산이 실패함


/* -------------------------------------------------------------------------- */
기본 코드를 실행해봅시다

console.log(1);
console.log(2);
console.log(3);
console.log(4);

결과 값
1
2
3
4


function callme() {
  console.log("Tell me about function calling");
}

console.log(1);
console.log(2);
console.log(3);
console.log(4);


함수를 정의한다고 실행되지 않는다.함수가 호출되어야 그 함수의 내용이 실행됩니다.

function finishJob(num) {
  console.log(`${num}번 요원의 정보를 받아왔습니다.`);
}

setTimeout(finishJob, 2000, 1); //? -> 작업을 예약하는 일이 전부이기 때문에, 비동기로 동작
setTimeout(finishJob, 1500, 2);
setTimeout(finishJob, 1000, 3);
console.log("정보 요청을 모두 보냈습니다.");

동기의(대략적인) 특징
동시에 여러 작업을 수행할 수 없다.
흐름을 예측하기 쉽다.먼저 수행되고 나중에 수행되는 것들이 명확하다.
  비동기의(대략적인) 특징
동시에 여러 작업을 수행할 수 있다.
흐름을 예측하기 어렵다. (무엇이 먼저 완료될 지 보장할 수 없다.)



